package bazel_testing

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"strings"
)

// Code related to the http_files rule for setting up a set of cached files.

// LoadCacheManifest returns a cache manifest that can be used to instantiate a
// content-addressable cache for bazel.
//
// The manifest path should specify the manifest.json file generated by an
// http_files rule.
func LoadCacheManifest(manifestPath string) (*CacheManifest, error) {
	manifestData, err := ioutil.ReadFile(manifestPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read manifest file %q: %v", manifestPath, err)
	}

	got := &CacheManifest{}
	if err := json.Unmarshal(manifestData, got); err != nil {
		return nil, fmt.Errorf("failed to unmarshal manifest file %q: %v", manifestPath, err)
	}
	if err := got.check(); err != nil {
		return nil, fmt.Errorf("failed to unmarshal manifest file %q: %v", manifestPath, err)
	}
	return got, nil
}

// CacheManifest describes the output of an http_files workspace rule.
//
// It contains a list of files and the URLs used to download them.
type CacheManifest struct {
	// DownloadedFiles describes the set of files in the cache.
	DownloadedFiles []*DownloadedFile
}

func (cm *CacheManifest) check() error {
	var errors []string
	for i, df := range cm.DownloadedFiles {
		if df.ChecksumType != "sha256" {
			errors = append(errors, fmt.Sprintf("DownloadedFile[%d] invalid: ChecksumType got %q, must be 'sha256'", i, df.ChecksumType))
		}
		if df.Checksum == "" {
			errors = append(errors, fmt.Sprintf("DownloadedFile[%d] invalid: empty Checksum value", i))
		}
		if df.RepoRelativePath == "" {
			errors = append(errors, fmt.Sprintf("DownloadedFile[%d] invalid: empty RepoRelativePath value", i))
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return fmt.Errorf("%d errors with CacheManifest:\n  %s", len(errors), strings.Join(errors, "\n  "))
}

// DownloadedFile is a single entry in the cache.
type DownloadedFile struct {
	// ChecksumType is always "sha256" for now
	ChecksumType string
	// The value of the checksum.
	Checksum string
	// List of URLs from which the file could be downloaded.
	URLs []string
	// Path of the file relative to the manifest.
	RepoRelativePath string
}
